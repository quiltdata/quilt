directive @admin on FIELD_DEFINITION

scalar Datetime

scalar Json

scalar JsonDict

type ContentIndexingSettings {
  extensions: [String!]!
  bytesDefault: Int!
  bytesMin: Int!
  bytesMax: Int!
}

type Config {
  contentIndexingSettings: ContentIndexingSettings! @admin
}

type BucketConfig {
  name: String!
  title: String!
  iconUrl: String
  description: String
  linkedData: Json
  overviewUrl: String
  tags: [String!]
  relevanceScore: Int!
  lastIndexed: Datetime
  snsNotificationArn: String @admin
  scannerParallelShardsDepth: Int @admin
  skipMetaDataIndexing: Boolean @admin
  fileExtensionsToIndex: [String!] @admin
  indexContentBytes: Int @admin
  permissions: [RoleBucketPermission!]! @admin
}

type UnmanagedRole {
  id: ID!
  name: String!
  arn: String
}

type ManagedRole {
  id: ID!
  name: String!
  arn: String
  permissions: [RoleBucketPermission!]!
}

union Role = UnmanagedRole | ManagedRole

enum BucketPermissionLevel {
  READ
  READ_WRITE
}

type RoleBucketPermission {
  role: Role!
  bucket: BucketConfig!
  level: BucketPermissionLevel
}

type AccessCountForDate {
  date: Date!
  value: Int!
}

type AccessCounts {
  total: Int!
  counts: [AccessCountForDate!]!
}

enum ObjectType {
  # TBD
}

type ObjectPreview {
  # TBD
}

interface ObjectLike {
  name: String! # absolute vs relative?
  size: Int!
  type: ObjectType!
  preview(opts?): ObjectPreview
}

type PhysicalObject {
  bucket: String!
  key: String!
  versionId: String!

  size: Int!
  hash: String! # optional?
  meta: JsonDict
  modified: Date! # optional
  # meta
  # type and preview stuff
}

type PackageEntryFile {
  name: String! # absolute vs relative?
  size: Int!
  meta: JsonDict
  # physicalKey
  physicalObject: PhysicalObject!
}

type PackageEntryDir {
  name: String!
  size: Int!
  meta: JsonDict
  children: PackageEntryList!
}

union PackageEntry = PackageEntryFile | PackageEntryDir

type PackageEntryList {
  total: Int!
  totalBytes: Int!
  page(number: Int = 1, perPage: Int = 50, prefix: String): [PackageEntry!]!
}

type PackageRevision {
  # link to package?
  pointer: String!
  hash: String!
  modified: Date!
  stats: PackageRevisionStats!
  message: String
  metadata: JsonDict!
  # header: do we need this?
  entries: PackageEntryList!
  entry(path: String!): PackageEntry
}

type PackageRevisionList {
  total: Int!
  page(number: Int = 1, perPage: Int = 10): [PackageRevision!]!
}

type Package {
  bucket: String!
  name: String!
  modified: Date!
  revisions: PackageRevisionList!
  revision(hashOrTag: String = "latest"): PackageRevision
  accessCounts(window: Int = 30): AccessCounts
}

type PackageList {
  # id? bucket + filter?
  total: Int!
  page(number: Int = 1, perPage: Int = 30): [Package!]!
}

type Query {
  config: Config!
  bucketConfigs: [BucketConfig!]!
  bucketConfig(name: String!): BucketConfig
  bucket(name: String!): Bucket! # probably not necessary atm
  # null if cant access packages -- return specific errors instead?
  packages(bucket: String!, filter: String): PackageList
  package(bucket: String!, name: String!): Package
  roles: [Role!]! @admin
  role(id: ID!): Role @admin
}

input BucketAddInput {
  name: String!
  title: String!
  iconUrl: String
  description: String
  linkedData: Json
  overviewUrl: String
  tags: [String!]
  relevanceScore: Int
  snsNotificationArn: String
  scannerParallelShardsDepth: Int
  skipMetaDataIndexing: Boolean
  fileExtensionsToIndex: [String!]
  indexContentBytes: Int
  setVersioning: Boolean
  delayScan: Boolean
}

input BucketUpdateInput {
  title: String!
  iconUrl: String
  description: String
  linkedData: Json
  overviewUrl: String
  tags: [String!]
  relevanceScore: Int
  snsNotificationArn: String
  scannerParallelShardsDepth: Int
  skipMetaDataIndexing: Boolean
  fileExtensionsToIndex: [String!]
  indexContentBytes: Int
  setVersioning: Boolean
}

type BucketAddSuccess {
  bucketConfig: BucketConfig!
}

type BucketNotFound {
  _: Boolean
}

type BucketAlreadyAdded {
  _: Boolean
}

type BucketDoesNotExist {
  _: Boolean
}

type BucketFileExtensionsToIndexInvalid {
  _: Boolean
}

type BucketIndexContentBytesInvalid {
  _: Boolean
}

type SnsInvalid {
  _: Boolean
}

type NotificationConfigurationError {
  _: Boolean
}

type NotificationTopicNotFound {
  _: Boolean
}

type InsufficientPermissions {
  _: Boolean
}

type IndexingInProgress {
  _: Boolean
}

union BucketAddResult =
    BucketAddSuccess
  | BucketAlreadyAdded
  | BucketDoesNotExist
  | BucketFileExtensionsToIndexInvalid
  | BucketIndexContentBytesInvalid
  | InsufficientPermissions
  | NotificationConfigurationError
  | NotificationTopicNotFound
  | SnsInvalid

type BucketUpdateSuccess {
  bucketConfig: BucketConfig!
}

union BucketUpdateResult =
    BucketUpdateSuccess
  | BucketFileExtensionsToIndexInvalid
  | BucketIndexContentBytesInvalid
  | BucketNotFound
  | NotificationConfigurationError
  | NotificationTopicNotFound
  | SnsInvalid

type BucketRemoveSuccess {
  _: Boolean
}

union BucketRemoveResult =
    BucketRemoveSuccess
  | BucketNotFound
  | IndexingInProgress

input PermissionInput {
  bucket: String!
  level: BucketPermissionLevel
}

input UnmanagedRoleInput {
  name: String!
  arn: String!
}

input ManagedRoleInput {
  name: String!
  permissions: [PermissionInput!]!
}

type RoleNameReserved {
  _: Boolean
}

type RoleNameExists {
  _: Boolean
}

type RoleNameInvalid {
  _: Boolean
}

type BucketConfigDoesNotExist {
  name: String!
}

type RoleDoesNotExist {
  _: Boolean
}

type RoleIsManaged {
  _: Boolean
}

type RoleIsUnmanaged {
  _: Boolean
}

type RoleCreateSuccess {
  role: Role!
}

union RoleCreateResult =
    RoleCreateSuccess
  | RoleNameReserved
  | RoleNameExists
  | RoleNameInvalid
  | BucketConfigDoesNotExist

type RoleUpdateSuccess {
  role: Role!
}

union RoleUpdateResult =
    RoleUpdateSuccess
  | RoleNameReserved
  | RoleNameExists
  | RoleNameInvalid
  | RoleIsManaged
  | RoleIsUnmanaged
  | BucketConfigDoesNotExist

type RoleDeleteSuccess {
  _: Boolean
}

type RoleAssigned {
  _: Boolean
}

union RoleDeleteResult = RoleDeleteSuccess | RoleDoesNotExist | RoleNameReserved | RoleAssigned

type Mutation {
  bucketAdd(input: BucketAddInput!): BucketAddResult! @admin
  bucketUpdate(name: String!, input: BucketUpdateInput!): BucketUpdateResult! @admin
  bucketRemove(name: String!): BucketRemoveResult! @admin

  roleCreateManaged(input: ManagedRoleInput!): RoleCreateResult! @admin
  roleCreateUnmanaged(input: UnmanagedRoleInput!): RoleCreateResult! @admin
  roleUpdateManaged(id: ID!, input: ManagedRoleInput!): RoleUpdateResult! @admin
  roleUpdateUnmanaged(id: ID!, input: UnmanagedRoleInput!): RoleUpdateResult! @admin
  roleDelete(id: ID!): RoleDeleteResult! @admin
}
