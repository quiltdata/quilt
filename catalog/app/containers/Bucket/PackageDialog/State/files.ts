import type { ErrorObject } from 'ajv'
import * as FP from 'fp-ts'
import * as R from 'ramda'
import * as React from 'react'

import * as Types from 'utils/types'
import * as JSONPointer from 'utils/JSONPointer'
import * as s3paths from 'utils/s3paths'
import * as Model from 'model'
import Log from 'utils/Logging'
import assertNever from 'utils/assertNever'

import * as FI from '../FilesState'
import { Manifest } from '../Manifest'

import type { FormStatus } from './form'
import { mkMetaValidator, SchemaStatus } from './schema'

const README_PATH = 'README.md'

export type FormFiles = {
  local: {
    file: FI.LocalFile

    path: string
    hash?: Model.Checksum | null
    meta?: Types.JsonRecord | null
    size: number | null
  }[]
  remote: {
    [path: string]: {
      physicalKey: string

      hash?: Model.Checksum
      meta?: Types.JsonRecord | null
      size?: number
    }
  }
}

export async function createReadmeFile(name: string) {
  const contents = [
    `# ${name}`,
    '\n\n',
    `Stub README for the **${name}** package generated by Quilt Catalog`,
    '\n',
  ]
  const f = new File(contents, README_PATH, { type: 'text/markdown' })
  const localFile = FI.computeHash(f) as FI.LocalFile
  await localFile.hash.promise

  return {
    file: localFile,
    path: README_PATH,
    hash: localFile.hash.value,
    size: localFile.size,
  }
}

type ManifestStatus =
  | { _tag: 'idle' }
  | { _tag: 'loading' }
  | { _tag: 'error'; error: Error }
  | { _tag: 'ready'; manifest: Manifest | undefined }

interface ValidationEntry {
  logical_key: string
  size: number
  meta?: Types.JsonRecord
}

type EntriesValidationErrors = Error | { [logical_key: string]: ErrorObject }

export type FilesStatus =
  | { _tag: 'error'; error?: Error; errors?: { [logicalKey: string]: ErrorObject } }
  | { _tag: 'ok' }

export interface FilesState {
  onChange: (f: Partial<FI.FilesState>) => void
  status: FilesStatus
  value: FI.FilesState
  initial: FI.FilesState // It is used only to revert to initial state
}

function mapErrorsToLogicalKeys(
  entries: readonly ValidationEntry[],
  errors?: (Error | ErrorObject)[], // actually, the type is ([Error] | ErrorObject[])
) {
  if (!errors?.length) return null
  if (errors.length === 1 && errors[0] instanceof Error) return errors[0]
  try {
    return (errors as ErrorObject[]).reduce(
      (memo: EntriesValidationErrors | null, error) => {
        if (!error.instancePath) {
          throw new Error(error.message)
        }
        const pointer = JSONPointer.parse(error.instancePath)
        const index: number = Number(pointer[0] as string)
        const logicalKey = entries[index].logical_key
        if (!memo)
          return {
            [logicalKey]: error,
          }
        return {
          ...memo,
          [logicalKey]: error,
        }
      },
      null,
    )
  } catch (e) {
    Log.debug(e)
    return e instanceof Error ? e : new Error(`${e}`)
  }
}

// Convert FilesState to entries consumed by Schema validation
function filesStateToEntries(files: FI.FilesState): readonly ValidationEntry[] {
  return FP.function.pipe(
    R.mergeLeft(files.added, files.existing),
    R.omit(Object.keys(files.deleted)),
    Object.entries,
    R.filter(([, file]) => file !== FI.EMPTY_DIR_MARKER),
    R.map(([path, file]) => ({
      logical_key: path,
      meta: file.meta?.user_meta || {},
      size: file.size,
    })),
  )
}

function mergeFiles(manifest: ManifestStatus, files?: Partial<FI.FilesState>) {
  const existing = manifest._tag === 'ready' ? manifest.manifest?.entries || {} : {}
  return {
    existing,
    added: files?.added || {},
    deleted: files?.deleted || {},
  }
}

export function useFiles(
  form: FormStatus,
  schema: SchemaStatus,
  manifest: ManifestStatus,
  open: boolean | FI.FilesState['added'],
): FilesState {
  const [initial, setInitial] = React.useState<FI.FilesState>({
    added: {},
    existing: {},
    deleted: {},
  })
  const [files, setFiles] = React.useState<Partial<FI.FilesState>>(initial.added)
  const value = React.useMemo(() => mergeFiles(manifest, files), [manifest, files])
  React.useEffect(() => {
    if (typeof open === 'object') {
      setFiles({ added: open })
    }
  }, [open])
  React.useEffect(() => {
    if (typeof open === 'object') {
      setInitial(mergeFiles(manifest, { added: open }))
    }
  }, [open, manifest])
  const validate = React.useMemo(() => {
    if (schema._tag === 'error') return () => [schema.error]
    if (schema._tag !== 'ready') return () => [new Error('Schema is not ready')]
    return mkMetaValidator(schema.schema)
  }, [schema])
  const status: FilesStatus = React.useMemo(() => {
    if (form._tag !== 'error') return { _tag: 'ok' }
    if (form.fields?.files) return { _tag: 'error', error: form.fields.files }

    // Validate hashes are ready and valid
    const hashihgError = FI.validateHashingComplete(value)
    switch (hashihgError) {
      case undefined:
        break
      case FI.HASHING:
        return { _tag: 'error', error: new Error('Please wait while we hash the files') }
      case FI.HASHING_ERROR:
        return {
          _tag: 'error',
          error: new Error(
            'Error hashing files, probably some of them are too large. Please try again or contact support.',
          ),
        }
      default:
        assertNever(hashihgError)
    }

    // Validate entries meta
    const entries = filesStateToEntries(value)
    const errors = validate(entries as unknown as Types.JsonArray)
    const mappedErros = mapErrorsToLogicalKeys(entries, errors)
    if (mappedErros instanceof Error) return { _tag: 'error', error: mappedErros }
    if (mappedErros) return { _tag: 'error', errors: mappedErros }
    return { _tag: 'ok' }
  }, [form, validate, value])
  return React.useMemo(
    () => ({ status, value, onChange: setFiles, initial }),
    [status, value, initial],
  )
}

export function groupAddedFiles({ added, deleted, existing }: FI.FilesState): FormFiles {
  const filesGroups = FI.groupAddedFiles(added)
  const local = filesGroups.local
    .filter(({ path, file }) => {
      const e = existing[path]
      return !e || !R.equals(e.hash, file.hash.value)
    })
    .map(({ path, file }) => ({
      path,
      hash: file.hash.value,
      meta: existing[path]?.meta || added[path]?.meta,
      size: file.size,
      file,
    }))

  const addedS3Files = filesGroups.remote.reduce(
    (memo, { path, file }) => ({
      ...memo,
      [path]: {
        physicalKey: s3paths.handleToS3Url(file),
        meta: file.meta,
      },
    }),
    {} as Record<string, Types.AtLeast<Model.PackageEntry, 'physicalKey'>>,
  )
  const existingS3Files: Model.PackageContentsFlatMap = R.omit(
    Object.keys(deleted),
    existing,
  )
  return {
    local,
    remote: {
      ...existingS3Files,
      ...addedS3Files,
    },
  }
}
