import type { ErrorObject } from 'ajv'
import cx from 'classnames'
import * as FF from 'final-form'
import * as FP from 'fp-ts'
import * as R from 'ramda'
import * as React from 'react'
import * as RF from 'react-final-form'
import * as RRDom from 'react-router-dom'
import * as M from '@material-ui/core'

import * as Intercom from 'components/Intercom'
import JsonValidationErrors from 'components/JsonValidationErrors'
import cfg from 'constants/config'
import * as AddToPackage from 'containers/AddToPackage'
import type * as Model from 'model'
import * as AWS from 'utils/AWS'
import AsyncResult from 'utils/AsyncResult'
import * as BucketPreferences from 'utils/BucketPreferences'
import * as Data from 'utils/Data'
import * as Dialogs from 'utils/Dialogs'
import { useMutation } from 'utils/GraphQL'
import assertNever from 'utils/assertNever'
import { mkFormError, mapInputErrors } from 'utils/formTools'
import * as s3paths from 'utils/s3paths'
import * as tagged from 'utils/taggedV2'
import * as Types from 'utils/types'
import * as validators from 'utils/validators'
import * as workflows from 'utils/workflows'

import * as Download from '../Download'
import * as Successors from '../Successors'
import * as Upload from '../Upload'
import * as requests from '../requests'

import DialogError from './DialogError'
import DialogLoading from './DialogLoading'
import DialogSuccess, { DialogSuccessRenderMessageProps } from './DialogSuccess'
import * as FI from './FilesInput'
import * as Layout from './Layout'
import * as MI from './MetaInput'
import * as PD from './PackageDialog'
import { isS3File } from './S3FilePicker'
import { FormSkeleton, MetaInputSkeleton } from './Skeleton'
import SubmitSpinner from './SubmitSpinner'
import { useUploads } from './Uploads'
import PACKAGE_CONSTRUCT from './gql/PackageConstruct.generated'
import { Manifest, EMPTY_MANIFEST_ENTRIES, useManifest } from './Manifest'

const CANCEL = 'cancel'
const README_PATH = 'README.md'

const ERRORS_MAP = {
  name: {
    required: 'Enter a package name',
    invalid: 'Invalid package name',
    pattern: `Name should match packages name pattern`,
  },
  msg: {
    required: 'Enter a commit message',
  },
  files: {
    schema: 'Files should match the schema',
    [FI.HASHING]: 'Please wait while we hash the files',
    [FI.HASHING_ERROR]:
      'Error hashing files, probably some of them are too large. Please try again or contact support.',
  },
}

type PartialPackageEntry = Types.AtLeast<Model.PackageEntry, 'physicalKey'>

// TODO: use tree as the main data model / source of truth?
interface LocalEntry {
  path: string
  file: FI.LocalFile
}

interface S3Entry {
  path: string
  file: Model.S3File
}

interface PackageCreationSuccess {
  name: string
  hash?: string
}

// Convert FilesState to entries consumed by Schema validation
function filesStateToEntries(files: FI.FilesState): PD.ValidationEntry[] {
  return FP.function.pipe(
    R.mergeLeft(files.added, files.existing),
    R.omit(Object.keys(files.deleted)),
    Object.entries,
    R.map(([path, file]) => ({
      logical_key: path,
      meta: file.meta?.user_meta || {},
      size: file.size,
    })),
  )
}

function createReadmeFile(name: string) {
  const contents = [
    `# ${name}`,
    '\n\n',
    `Stub README for the **${name}** package generated by Quilt Catalog`,
    '\n',
  ]
  const f = new File(contents, README_PATH, { type: 'text/markdown' })
  return FI.computeHash(f) as FI.LocalFile
}

// XXX: move to dialogs module
interface DialogsOpenProps {
  close: (reason?: string) => void
}

function ConfirmReadme({ close }: DialogsOpenProps) {
  return (
    <>
      <M.DialogTitle>Add a README file?</M.DialogTitle>
      <M.DialogContent>
        <M.DialogContentText>
          You are about to push an empty package.
          <br />
          Would you like to add a stub <b>README.md</b> file?
        </M.DialogContentText>
      </M.DialogContent>
      <M.DialogActions>
        <M.Button onClick={() => close('cancel')} color="primary">
          Cancel
        </M.Button>
        <M.Button onClick={() => close('empty')} color="primary" variant="outlined">
          Continue with empty package
        </M.Button>
        <M.Button onClick={() => close('readme')} color="primary" variant="contained">
          Add README.md
        </M.Button>
      </M.DialogActions>
    </>
  )
}

interface FormErrorProps {
  submitting: boolean
  error: React.ReactNode
}

function FormError({ submitting, error }: FormErrorProps) {
  if (submitting || !error || error === CANCEL) return null
  return (
    <M.Box flexGrow={1} display="flex" alignItems="center" pl={2}>
      <M.Icon color="error">error_outline</M.Icon>
      <M.Box pl={1} />
      <M.Typography variant="body2" color="error">
        {error}
      </M.Typography>
    </M.Box>
  )
}

const useStyles = M.makeStyles((t) => ({
  files: {
    height: '100%',
  },
  filesWithError: {
    height: `calc(90% - ${t.spacing()}px)`,
  },
  filesError: {
    marginTop: t.spacing(),
    maxHeight: t.spacing(9),
    overflowY: 'auto',
  },
  form: {
    height: '100%',
  },
  meta: {
    display: 'flex',
    flexDirection: 'column',
    paddingTop: t.spacing(3),
    overflowY: 'auto',
  },
}))

interface PackageCreationFormProps {
  bucket: string
  close: () => void
  initial?: {
    name?: string
    meta?: Types.JsonRecord
    msg?: string
    workflowId?: string
    entries?: Model.PackageContentsFlatMap
    path?: string
  }
  successor: workflows.Successor
  onSuccessor: (successor: workflows.Successor) => void
  setSubmitting: (submitting: boolean) => void
  setSuccess: (success: PackageCreationSuccess) => void
  setWorkflow: (workflow: workflows.Workflow) => void
  sourceBuckets: BucketPreferences.SourceBuckets
  workflowsConfig: workflows.WorkflowsConfig
  delayHashing: boolean
  disableStateDisplay: boolean
  dropZoneOnly: boolean
  ui?: {
    title?: React.ReactNode
    submit?: React.ReactNode
    resetFiles?: React.ReactNode
  }
}

function PackageCreationForm({
  bucket,
  close,
  initial,
  successor,
  onSuccessor,
  responseError,
  schema,
  schemaLoading,
  selectedWorkflow,
  setSubmitting,
  setSuccess,
  setWorkflow,
  sourceBuckets,
  validate: validateMetaInput,
  workflowsConfig,
  delayHashing,
  disableStateDisplay,
  dropZoneOnly,
  ui = {},
}: PackageCreationFormProps & PD.SchemaFetcherRenderProps) {
  const addToPackage = AddToPackage.use()
  const nameValidator = PD.useNameValidator(selectedWorkflow)
  const nameExistence = PD.useNameExistence(successor.slug)
  const [nameWarning, setNameWarning] = React.useState<React.ReactNode>('')
  const [metaHeight, setMetaHeight] = React.useState(0)
  const classes = useStyles()
  const dialogContentClasses = PD.useContentStyles({ metaHeight })
  const validateWorkflow = PD.useWorkflowValidator(workflowsConfig)

  const dialogs = Dialogs.use()

  const [entriesError, setEntriesError] = React.useState<(Error | ErrorObject)[] | null>(
    null,
  )

  const [selectedBucket, selectBucket] = React.useState(sourceBuckets.getDefault)

  const existingEntries = initial?.entries ?? EMPTY_MANIFEST_ENTRIES

  const initialFiles: FI.FilesState = React.useMemo(
    () => ({
      existing: existingEntries,
      added: addToPackage?.entries || {},
      deleted: {},
    }),
    [existingEntries, addToPackage],
  )

  const uploads = useUploads()

  const onFilesAction = React.useMemo(
    () =>
      FI.FilesAction.match({
        _: () => {},
        Revert: uploads.remove,
        RevertDir: uploads.removeByPrefix,
        Reset: uploads.reset,
      }),
    [uploads],
  )

  const constructPackage = useMutation(PACKAGE_CONSTRUCT)
  const validateEntries = PD.useEntriesValidator(selectedWorkflow)

  const uploadPackage = Upload.useUploadPackage()

  interface SubmitArgs {
    name: string
    msg: string
    meta: {}
    localFolder?: string
    workflow: workflows.Workflow
  }
  interface SubmitWebArgs extends SubmitArgs {
    files: FI.FilesState
  }
  interface SubmitElectronArgs extends SubmitArgs {
    localFolder: string
  }

  const onSubmitElectron = React.useCallback(
    async ({ name, msg, localFolder, meta, workflow }: SubmitElectronArgs) => {
      const payload = {
        entry: localFolder || '',
        message: msg,
        meta,
        workflow,
      }
      const uploadResult = await uploadPackage(
        payload,
        { name, bucket: successor.slug },
        schema,
      )
      setSuccess({ name, hash: uploadResult?.hash })
      return null
    },
    [successor.slug, schema, setSuccess, uploadPackage],
  )

  const onSubmitWeb = async ({ name, msg, files, meta, workflow }: SubmitWebArgs) => {
    const addedS3Entries: S3Entry[] = []
    const addedLocalEntries: LocalEntry[] = []
    Object.entries(files.added).forEach(([path, file]) => {
      if (isS3File(file)) {
        addedS3Entries.push({ path, file })
      } else {
        addedLocalEntries.push({ path, file })
      }
    })

    const toUpload = addedLocalEntries.filter(({ path, file }) => {
      const e = files.existing[path]
      return !e || e.hash !== file.hash.value
    })

    const entries = filesStateToEntries(files)

    if (!entries.length) {
      const reason = await dialogs.open((props: DialogsOpenProps) => (
        <ConfirmReadme {...props} />
      ))
      if (reason === 'cancel') return mkFormError(CANCEL)
      if (reason === 'readme') {
        const file = createReadmeFile(name)
        entries.push({ logical_key: README_PATH, size: file.size, meta: {} })
        toUpload.push({ path: README_PATH, file })
      }
    }

    const error = await validateEntries(entries)
    if (error?.length) {
      setEntriesError(error)
      return {
        files: 'schema',
      }
    }

    let uploadedEntries
    try {
      uploadedEntries = await uploads.upload({
        files: toUpload,
        bucket: successor.slug,
        prefix: name,
        getMeta: (path) => files.existing[path]?.meta || files.added[path]?.meta,
      })
    } catch (e) {
      // eslint-disable-next-line no-console
      console.error('Error uploading files:')
      // eslint-disable-next-line no-console
      console.error(e)
      return mkFormError(PD.ERROR_MESSAGES.UPLOAD)
    }

    const s3Entries = FP.function.pipe(
      addedS3Entries,
      R.map(
        ({ path, file }) =>
          [
            path,
            { physicalKey: s3paths.handleToS3Url(file), meta: file.meta },
          ] as R.KeyValuePair<string, PartialPackageEntry>,
      ),
      R.fromPairs,
    )

    const allEntries = FP.function.pipe(
      files.existing,
      R.omit(Object.keys(files.deleted)),
      R.mergeLeft(uploadedEntries),
      R.mergeLeft(s3Entries),
      R.toPairs,
      R.map(([logicalKey, data]: [string, PartialPackageEntry]) => ({
        logicalKey,
        physicalKey: data.physicalKey,
        hash: data.hash ?? null,
        meta: data.meta ?? null,
        size: data.size ?? null,
      })),
      R.sortBy(R.prop('logicalKey')),
    )

    try {
      const { packageConstruct: r } = await constructPackage({
        params: {
          bucket: successor.slug,
          name,
          message: msg,
          userMeta: requests.getMetaValue(meta, schema) ?? null,
          workflow:
            // eslint-disable-next-line no-nested-ternary
            workflow.slug === workflows.notAvailable
              ? null
              : workflow.slug === workflows.notSelected
              ? ''
              : workflow.slug,
        },
        src: {
          entries: allEntries,
        },
      })
      switch (r.__typename) {
        case 'PackagePushSuccess':
          setSuccess({ name, hash: r.revision.hash })
          return
        case 'OperationError':
          return mkFormError(r.message)
        case 'InvalidInput':
          return mapInputErrors(r.errors, { 'src.entries': 'files' })
        default:
          assertNever(r)
      }
    } catch (e: any) {
      // eslint-disable-next-line no-console
      console.error('Error creating manifest:')
      // eslint-disable-next-line no-console
      console.error(e)
      return mkFormError(
        e.message ? `Unexpected error: ${e.message}` : PD.ERROR_MESSAGES.MANIFEST,
      )
    }
  }

  const onSubmitWrapped = async (args: SubmitWebArgs | SubmitElectronArgs) => {
    setSubmitting(true)
    try {
      if (cfg.desktop) {
        return await onSubmitElectron(args as SubmitElectronArgs)
      }
      return await onSubmitWeb(args as SubmitWebArgs)
    } finally {
      addToPackage?.clear()
      setSubmitting(false)
    }
  }

  const handleNameChange = React.useCallback(
    async (name) => {
      const nameExists = await nameExistence.validate(name)
      const warning = <PD.PackageNameWarning exists={!!nameExists} />

      if (warning !== nameWarning) {
        setNameWarning(warning)
      }
    },
    [nameWarning, nameExistence],
  )

  const [editorElement, setEditorElement] = React.useState<HTMLDivElement | null>(null)
  const resizeObserver = React.useMemo(
    () =>
      new window.ResizeObserver((entries) => {
        const { height } = entries[0]!.contentRect
        setMetaHeight(height)
      }),
    [setMetaHeight],
  )
  const [filesDisabled, setFilesDisabled] = React.useState(false)
  const onFormChange = React.useCallback(
    ({ dirtyFields, values }) => {
      if (dirtyFields?.name) handleNameChange(values.name)
    },
    [handleNameChange],
  )

  React.useEffect(() => {
    if (editorElement) resizeObserver.observe(editorElement)
    return () => {
      if (editorElement) resizeObserver.unobserve(editorElement)
    }
  }, [editorElement, resizeObserver])

  const validateFiles = React.useCallback(
    async (files: FI.FilesState) => {
      const hashihgError = delayHashing && FI.validateHashingComplete(files)
      if (hashihgError) return hashihgError

      setFilesDisabled(true)
      const entries = filesStateToEntries(files)
      const errors = await validateEntries(entries)
      setEntriesError(errors || null)
      setFilesDisabled(false)
      if (errors?.length) {
        return 'schema'
      }
    },
    [delayHashing, validateEntries],
  )

  const onFilesChange = React.useCallback(
    (submit) =>
      async ({ dirtyFields, hasValidationErrors }: FF.FormState<SubmitWebArgs>) => {
        // NOTE:
        // We show error while files are hashing
        // then submit after hashing is ended because
        // `hasValidationErrors` turns to false
        // FIXME: hasValidationErrors == "wait for files hashing"
        if (!dirtyFields.files || hasValidationErrors) return
        await submit()
      },
    [],
  )

  // HACK: FIXME: it triggers name validation with correct workflow
  const [hideMeta, setHideMeta] = React.useState(false)

  // TODO: move useLocalFolder to its own component shared by Download and Upload
  const [defaultLocalFolder] = Download.useLocalFolder()

  const titlePrefix = React.useMemo(() => {
    if (ui.title) return `${ui.title} in`
    if (dropZoneOnly && R.isEmpty(existingEntries)) return 'Add files to package in'
    return 'Create package in'
  }, [ui.title, dropZoneOnly, existingEntries])

  return (
    <RF.Form
      onSubmit={onSubmitWrapped}
      subscription={{
        error: true,
        errors: dropZoneOnly,
        hasValidationErrors: true,
        submitError: true,
        submitFailed: true,
        submitting: true,
      }}
      validate={PD.useCryptoApiValidation()}
    >
      {({
        error,
        errors,
        hasValidationErrors,
        submitError,
        submitFailed,
        submitting,
        handleSubmit,
      }) => (
        <>
          {dialogs.render({ fullWidth: true, maxWidth: 'sm' })}
          <M.DialogTitle>
            {titlePrefix}
            <Successors.Dropdown
              bucket={bucket || ''}
              successor={successor}
              onChange={onSuccessor}
            />{' '}
            bucket
          </M.DialogTitle>
          <M.DialogContent classes={dialogContentClasses}>
            <form className={classes.form} onSubmit={handleSubmit}>
              {dropZoneOnly && (
                <RF.FormSpy
                  subscription={{ dirtyFields: true, hasValidationErrors: true }}
                  onChange={onFilesChange(handleSubmit)}
                />
              )}

              <RF.FormSpy
                subscription={{ dirtyFields: true, values: true }}
                onChange={onFormChange}
              />

              <RF.FormSpy
                subscription={{ modified: true, values: true }}
                onChange={({ modified, values }) => {
                  if (modified!.workflow && values.workflow !== selectedWorkflow) {
                    setWorkflow(values.workflow)

                    // HACK: FIXME: it triggers name validation with correct workflow
                    setHideMeta(true)
                    setTimeout(() => {
                      setHideMeta(false)
                    }, 300)
                  }
                }}
              />

              <Layout.Container>
                <Layout.LeftColumn hide={dropZoneOnly}>
                  <RF.Field
                    component={PD.WorkflowInput}
                    bucket={bucket}
                    name="workflow"
                    workflowsConfig={workflowsConfig}
                    initialValue={selectedWorkflow}
                    validate={validateWorkflow}
                    validateFields={['meta', 'workflow']}
                    errors={{
                      required: 'Workflow is required for this bucket.',
                    }}
                  />

                  <RF.Field
                    component={PD.PackageNameInput}
                    workflow={selectedWorkflow || workflowsConfig}
                    initialValue={initial?.name}
                    name="name"
                    validate={validators.composeAsync(
                      validators.required,
                      nameValidator.validate,
                    )}
                    validateFields={['name']}
                    errors={{
                      required: ERRORS_MAP.name.required,
                      invalid: ERRORS_MAP.name.invalid,
                      pattern: `Name should match ${selectedWorkflow?.packageNamePattern}`,
                    }}
                    helperText={nameWarning}
                    validating={nameValidator.processing}
                  />

                  <RF.Field
                    component={PD.CommitMessageInput}
                    name="msg"
                    validate={validators.required as FF.FieldValidator<string>}
                    validateFields={['msg']}
                    initialValue={initial?.msg}
                    errors={{
                      required: ERRORS_MAP.msg.required,
                    }}
                  />

                  {schemaLoading || hideMeta ? (
                    <MetaInputSkeleton className={classes.meta} ref={setEditorElement} />
                  ) : (
                    <RF.Field
                      className={classes.meta}
                      component={MI.MetaInput}
                      name="meta"
                      bucket={bucket}
                      schema={schema}
                      schemaError={responseError}
                      validate={validateMetaInput}
                      validateFields={['meta']}
                      isEqual={R.equals}
                      initialValue={initial?.meta || MI.EMPTY_META_VALUE}
                      ref={setEditorElement}
                    />
                  )}
                </Layout.LeftColumn>

                <Layout.RightColumn fullWidth={dropZoneOnly}>
                  {cfg.desktop ? (
                    <RF.Field
                      className={cx(classes.files, {
                        [classes.filesWithError]: !!entriesError,
                      })}
                      component={Upload.LocalFolderInput}
                      initialValue={defaultLocalFolder}
                      name="localFolder"
                      title="Local directory"
                      errors={{
                        required: 'Add directory to create a package',
                      }}
                      validate={validators.required as FF.FieldValidator<string>}
                    />
                  ) : (
                    <RF.Field
                      className={cx(classes.files, {
                        [classes.filesWithError]: !!entriesError,
                      })}
                      // @ts-expect-error
                      component={FI.FilesInput}
                      name="files"
                      validate={validateFiles as FF.FieldValidator<$TSFixMe>}
                      validateFields={['files']}
                      errors={ERRORS_MAP.files}
                      totalProgress={uploads.progress}
                      title="Files"
                      onFilesAction={onFilesAction}
                      isEqual={R.equals}
                      initialValue={initialFiles}
                      bucket={selectedBucket}
                      buckets={sourceBuckets.list}
                      selectBucket={selectBucket}
                      delayHashing={delayHashing}
                      disableStateDisplay={disableStateDisplay}
                      ui={{ reset: ui.resetFiles }}
                      initialS3Path={initial?.path}
                      validationErrors={submitFailed ? entriesError : []}
                      disabled={filesDisabled}
                    />
                  )}

                  <JsonValidationErrors
                    className={classes.filesError}
                    error={submitFailed ? entriesError : []}
                  />
                </Layout.RightColumn>
              </Layout.Container>

              <input type="submit" style={{ display: 'none' }} />
            </form>
          </M.DialogContent>
          <M.DialogActions>
            {!!errors &&
              Object.entries(errors).map(([input, err]) => (
                <FormError
                  submitting={submitting}
                  error={R.path([input, err], ERRORS_MAP)}
                />
              ))}
            {submitting && (
              <SubmitSpinner value={uploads.progress.percent}>
                {uploads.progress.percent < 100 ? 'Uploading files' : 'Writing manifest'}
              </SubmitSpinner>
            )}

            <FormError submitting={submitting} error={error || submitError} />

            <M.Button onClick={close} disabled={submitting}>
              Cancel
            </M.Button>
            <M.Button
              onClick={handleSubmit}
              variant="contained"
              color="primary"
              disabled={
                submitting || (submitFailed && hasValidationErrors) || dropZoneOnly
              }
            >
              {ui.submit || 'Create'}
            </M.Button>
          </M.DialogActions>
        </>
      )}
    </RF.Form>
  )
}

function prependSourceBucket(
  buckets: BucketPreferences.SourceBuckets,
  bucket: string,
): BucketPreferences.SourceBuckets {
  return {
    getDefault: () => bucket,
    list: R.prepend(bucket, buckets.list),
  }
}

function useInitialState(id?: string) {
  const history = RRDom.useHistory()
  const location = RRDom.useLocation()
  const searchParams = React.useMemo(
    () => new URLSearchParams(location.search),
    [location.search],
  )
  const msg = searchParams.get('msg') || undefined
  const nameOverride = searchParams.get('name') || undefined
  const workflowId = searchParams.get('workflow') || undefined
  const dropZoneOnly = searchParams.has('dropZoneOnly')
  const getInitial = React.useCallback(
    (packageName?: string, path?: string, manifest?: Manifest) =>
      R.mergeRight(manifest || {}, {
        msg,
        name: nameOverride || packageName,
        path,
        workflowId,
      }),
    [msg, nameOverride, workflowId],
  )
  const isOpen = id
    ? searchParams.get('createPackage') === id
    : searchParams.has('createPackage')
  const setOpen = React.useCallback(
    (shouldOpen: boolean) => {
      if (shouldOpen) {
        searchParams.set('createPackage', 'true')
      } else {
        searchParams.delete('msg')
        searchParams.delete('name')
        searchParams.delete('workflow')
        searchParams.delete('dropZoneOnly')
        searchParams.delete('createPackage')
      }
      history.push({
        search: searchParams.toString(),
      })
    },
    [searchParams, history],
  )
  return { dropZoneOnly, getInitial, isOpen, setOpen }
}

const DialogState = tagged.create(
  'app/containers/Bucket/PackageDialog/PackageCreationForm:DialogState' as const,
  {
    Closed: () => {},
    Loading: () => {},
    Error: (e: Error) => e,
    Form: (v: {
      manifest?: Manifest
      workflowsConfig: workflows.WorkflowsConfig
      sourceBuckets: BucketPreferences.SourceBuckets
    }) => v,
    Success: (v: PackageCreationSuccess) => v,
  },
)

// eslint-disable-next-line @typescript-eslint/no-redeclare
type DialogState = tagged.InstanceOf<typeof DialogState>

const EMPTY_MANIFEST_RESULT = AsyncResult.Ok()

export interface PackageCreationDialogUIOptions {
  resetFiles?: React.ReactNode
  submit?: React.ReactNode
  successBrowse?: React.ReactNode
  successRenderMessage?: (props: DialogSuccessRenderMessageProps) => React.ReactNode
  successTitle?: React.ReactNode
  title?: React.ReactNode
}

interface UsePackageCreationDialogProps {
  id?: string
  src: {
    bucket: string
    packageHandle?: {
      name: string
      hashOrTag?: string
    }
    s3Path?: string
  }
  successor: workflows.Successor // FIXME: successor -> dst
  onSuccessor: (successor: workflows.Successor) => void
  delayHashing?: boolean
  disableStateDisplay?: boolean
  ui: PackageCreationDialogUIOptions
}

export function PackageCreationDialog({
  id,
  src,
  successor,
  onSuccessor,
  delayHashing = false,
  disableStateDisplay = false,
  ui = {},
}: UsePackageCreationDialogProps) {
  const { dropZoneOnly, isOpen, setOpen, getInitial } = useInitialState(id)

  const [success, setSuccess] = React.useState<PackageCreationSuccess | false>(false)
  const [submitting, setSubmitting] = React.useState(false)
  const [workflow, setWorkflow] = React.useState<workflows.Workflow>()
  const addToPackage = AddToPackage.use()

  const s3 = AWS.S3.use()
  const workflowsData = Data.use(
    requests.workflowsConfig,
    { s3, bucket: successor.slug },
    { noAutoFetch: !src.bucket },
  )
  // XXX: use AsyncResult
  const { preferences } = BucketPreferences.use()

  const manifestData = useManifest({
    bucket: src.bucket,
    // this only gets passed when src is defined, so it should be always non-null when the query gets executed
    name: src.packageHandle?.name!,
    hashOrTag: src.packageHandle?.hashOrTag,
    pause: !(src.packageHandle && isOpen),
  })

  const manifestResult = src.packageHandle ? manifestData.result : EMPTY_MANIFEST_RESULT

  // AsyncResult<Model.PackageContentsFlatMap | undefined>
  const data = React.useMemo(
    () =>
      workflowsData.case({
        Ok: (workflowsConfig: workflows.WorkflowsConfig) =>
          AsyncResult.case(
            {
              Ok: (manifest: Manifest | undefined) =>
                preferences
                  ? AsyncResult.Ok({
                      manifest,
                      workflowsConfig,
                      sourceBuckets:
                        src.s3Path === undefined
                          ? preferences.ui.sourceBuckets
                          : prependSourceBucket(preferences.ui.sourceBuckets, src.bucket),
                    })
                  : AsyncResult.Pending(),
              _: R.identity,
            },
            manifestResult,
          ),
        _: R.identity,
      }),
    [src.bucket, src.s3Path, workflowsData, manifestResult, preferences],
  )

  const close = React.useCallback(() => {
    if (submitting) return
    setOpen(false)
    setWorkflow(undefined) // TODO: is this necessary?
    addToPackage?.clear()
    setSuccess(false)
  }, [addToPackage, submitting, setOpen])

  Intercom.usePauseVisibilityWhen(isOpen)

  const state = React.useMemo<DialogState>(() => {
    if (!isOpen) return DialogState.Closed()
    if (success) return DialogState.Success(success)
    return AsyncResult.case(
      {
        Ok: DialogState.Form,
        Err: DialogState.Error,
        _: DialogState.Loading,
      },
      data,
    )
  }, [isOpen, success, data])

  return (
    <M.Dialog
      fullWidth
      maxWidth={success ? 'sm' : 'lg'}
      onClose={close}
      open={isOpen}
      scroll="body"
    >
      {DialogState.match(
        {
          Closed: () => null,
          Loading: () => (
            <DialogLoading
              skeletonElement={<FormSkeleton dropZoneOnly={dropZoneOnly} />}
              title="Fetching package manifest. One moment…"
              submitText={ui.submit}
              onCancel={close}
            />
          ),
          Error: (e) => (
            <DialogError
              bucket={src.bucket}
              error={e}
              skeletonElement={<FormSkeleton animate={false} />}
              title={ui.title || 'Create package'}
              submitText={ui.submit}
              onCancel={close}
            />
          ),
          Form: ({ manifest, workflowsConfig, sourceBuckets }) => {
            const initial = getInitial(src.packageHandle?.name, src.s3Path, manifest)
            return (
              <PD.SchemaFetcher
                initialWorkflowId={initial?.workflowId || manifest?.workflowId}
                workflowsConfig={workflowsConfig}
                workflow={workflow}
              >
                {(schemaProps) => (
                  <PackageCreationForm
                    {...schemaProps}
                    {...{
                      bucket: src.bucket,
                      successor,
                      close,
                      setSubmitting,
                      setSuccess,
                      setWorkflow,
                      workflowsConfig,
                      sourceBuckets,
                      initial,
                      delayHashing,
                      disableStateDisplay,
                      dropZoneOnly,
                      onSuccessor,
                      ui: {
                        title: ui.title,
                        submit: ui.submit,
                        resetFiles: ui.resetFiles,
                      },
                    }}
                  />
                )}
              </PD.SchemaFetcher>
            )
          },
          Success: (props) => (
            <DialogSuccess
              {...props}
              bucket={successor.slug}
              onClose={close}
              browseText={ui.successBrowse}
              title={ui.successTitle}
              renderMessage={ui.successRenderMessage}
            />
          ),
        },
        state,
      )}
    </M.Dialog>
  )
}
