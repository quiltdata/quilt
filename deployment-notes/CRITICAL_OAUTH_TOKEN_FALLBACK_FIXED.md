# üî• CRITICAL FIX: OAuth Token Fallback Removed - Version 1.64.1a12

## Deployment Summary

**Deployed:** October 1, 2025  
**Version:** 1.64.1a12  
**Task Definition:** sales-prod-nginx_catalog:100  
**Status:** ‚úÖ COMPLETED  
**Image:** `...@sha256:ac4764abba84d371f7fe3ecfd5afca8c0cc4a64e7b0efbc761346737277e9377`

## Critical Issue Discovered

### The Problem

The `MCPContextProvider` was sending the **WRONG TOKEN TYPE** to the MCP backend:

**Bad Token (OAuth only):**
```json
{
  "id": "8795f0cc-8deb-40dd-9132-13357c983984",
  "uuid": "71298bde-1d25-4e52-bf16-a37b8cf6284c",
  "exp": 1767064650
}
```
‚ùå Only 3 fields  
‚ùå No roles, permissions, or buckets  
‚ùå Backend rejects this token

**Good Token (Enhanced):**
```json
{
  "id": "8795f0cc-...",
  "uuid": "fc8911bf-...",
  "exp": 1767054010,
  "iss": "quilt-frontend",
  "aud": "quilt-mcp-server",
  "sub": "8795f0cc-...",
  "iat": 1759284695,
  "jti": "mg7con5e2ghb",
  "scope": "write",
  "level": "write",
  "roles": ["ReadWriteQuiltV2-sales-prod"],
  "permissions": [24 S3/Athena permissions],
  "buckets": [32 bucket names]
}
```
‚úÖ Full JWT structure  
‚úÖ Has roles, permissions, buckets  
‚úÖ Backend can authenticate and authorize

### Root Cause

**File:** `catalog/app/components/Assistant/MCP/MCPContextProvider.tsx`  
**Lines:** 220-226

The `extractTokenFromStore` function had a **dangerous fallback**:

```typescript
// OLD CODE (WRONG):
if (enhancedToken) {
  return enhancedToken  // ‚úÖ Good
}

// Fallback: get original token directly from Redux
const { token } = findTokenInState(reduxState)
if (token) {
  return token  // ‚ùå BAD! Returns basic OAuth token
}
```

This fallback meant that whenever `DynamicAuthManager.getCurrentToken()` failed or was slow, the MCP client would send the **basic OAuth token** instead of waiting for the enhanced token.

### The Fix

**Removed the fallback entirely:**

```typescript
// NEW CODE (CORRECT):
if (enhancedToken) {
  console.log('‚úÖ Enhanced token', { tokenLength, tokenPreview })
  return enhancedToken
}

// CRITICAL: Do NOT fall back to basic OAuth token!
console.error('‚ùå DynamicAuthManager failed to generate enhanced token')
console.error('   Returning null to prevent wrong token type')
return null  // Forces retry or abort instead of using wrong token
```

Now if the enhanced token isn't available, we return `null` instead of sending the wrong token type. This forces the retry logic in `sendInitializedNotification` to work correctly.

## Testing Instructions

### 1. Hard Refresh Browser
```
Cmd + Shift + R (Mac)
```

### 2. Verify Version
```javascript
console.log(window.QUILT_CATALOG_CONFIG.stackVersion)
// Must show: 1.64.1a12
```

### 3. Check Token Type
```javascript
const authManager = window.__dynamicAuthManager
await authManager.clearCache()
const token = await authManager.getCurrentToken()

// Decode token
const parts = token.split('.')
const payload = JSON.parse(atob(parts[1] + '='.repeat((4 - (parts[1].length % 4)) % 4)))

console.log('Token fields:', Object.keys(payload))
console.log('Has roles:', !!payload.roles)
console.log('Has permissions:', !!payload.permissions)
console.log('Has buckets:', !!payload.buckets)
console.log('Token length:', token.length)

// Should show:
// Token fields: ["id", "uuid", "exp", "iss", "aud", "sub", "iat", "jti", "scope", "level", "roles", "permissions", "buckets"]
// Has roles: true
// Has permissions: true
// Has buckets: true
// Token length: ~2367 (not ~200!)
```

### 4. Test MCP Authentication

Open Qurator and watch console logs:

**Expected:**
```
‚úÖ MCP Client: Enhanced token generated by DynamicAuthManager
  {tokenLength: 2367, tokenPreview: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIs..."}
‚úÖ Sending notifications/initialized with Authorization header
  {tokenLength: 2367, hasAuthHeader: true, allHeaders: [...]}
‚úÖ notifications/initialized sent successfully
```

**Backend should log:**
```
‚úÖ JWT authentication succeeded for sub=8795f0cc-... (permissions=24, buckets=32, roles=1)
```

## Impact

This was a **critical bug** that explained why:
- ‚úÖ JWT signatures were valid (both sides using correct 64-char secret)
- ‚úÖ Frontend was generating enhanced tokens correctly
- ‚ùå Backend was still rejecting requests ("wrong signing secret")

The backend wasn't seeing a "wrong signing secret" - it was seeing the **basic OAuth token** which has a completely different structure and wasn't signed with the enhanced secret!

## Verification

After deployment, the token in network requests should be **~2367 bytes**, not **~200 bytes**.

**Before (WRONG):**
```
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6Ijg3OTVmMGNjLThkZWItNDBkZC05MTMyLTEzMzU3Yzk4Mzk4NCIsInV1aWQiOiI3MTI5OGJkZS0xZDI1LTRlNTItYmYxNi1hMzdiOGNmNjI4NGMiLCJleHAiOjE3NjcwNjQ2NTB9.cK_8y0HM2dJLVauvDZEAO1_hc2f6fcKRB76NDnQyRk4
```
(~200 bytes, basic OAuth token)

**After (CORRECT):**
```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImZyb250ZW5kLWVuaGFuY2VkIn0.eyJpZCI6Ijg3OTVmMGNjLThkZWItNDBkZC05MTMyLTEzMzU3Yzk4Mzk4NCIsInV1aWQiOiJmYzg5MTFiZi1jMmIyLTRlMTgtOWMwYy0wYzVlYzlhNmYxNzciLCJleHAiOjE3NjcwNTQwMTAsImlzcyI6InF1aWx0LWZyb250ZW5kIiwiYXVkIjoicXVpbHQtbWNwLXNlcnZlciIsInN1YiI6Ijg3OTVmMGNjLThkZWItNDBkZC05MTMyLTEzMzU3Yzk4Mzk4NCIsImlhdCI6MTc1OTI4NDY5NSwianRpIjoibWc3Y29uNWUyZ2hiIiwic2NvcGUiOiJ3cml0ZSIsImxldmVsIjoid3JpdGUiLCJyb2xlcyI6WyJSZWFkV3JpdGVRdWlsdFYyLXNhbGVzLXByb2QiXSwicGVybWlzc2lvbnMiOlsiYXRoZW5hOkJhdGNoR2V0UXVlcnlFeGVjdXRpb24iLCJhdGhlbmE6R2V0UXVlcnlFeGVjdXRpb24iLCJhdGhlbmE6R2V0UXVlcnlSZXN1bHRzIiwiYXRoZW5hOkxpc3RRdWVyeUV4ZWN1dGlvbnMiLCJhdGhlbmE6TGlzdFdvcmtHcm91cHMiLCJhdGhlbmE6U3RhcnRRdWVyeUV4ZWN1dGlvbiIsImF0aGVuYTpTdG9wUXVlcnlFeGVjdXRpb24iLCJnbHVlOkdldERhdGFiYXNlIiwiZ2x1ZTpHZXREYXRhYmFzZXMiLCJnbHVlOkdldFRhYmxlIiwiZ2x1ZTpHZXRUYWJsZXMiLCJpYW06R2V0UG9saWN5IiwiaWFtOkdldFBvbGljeVZlcnNpb24iLCJpYW06TGlzdEF0dGFjaGVkVXNlclBvbGljaWVzIiwiaWFtOkxpc3RVc2VyUG9saWNpZXMiLCJzMzpBYm9ydE11bHRpcGFydFVwbG9hZCIsInMzOkRlbGV0ZU9iamVjdCIsInMzOkdldEJ1Y2tldExvY2F0aW9uIiwiczM6R2V0T2JqZWN0IiwiczM6R2V0T2JqZWN0VmVyc2lvbiIsInMzOkxpc3RBbGxNeUJ1Y2tldHMiLCJzMzpMaXN0QnVja2V0IiwiczM6UHV0T2JqZWN0IiwiczM6UHV0T2JqZWN0QWNsIl0sImJ1Y2tldHMiOlsiY2VsbHBhaW50aW5nLWdhbGxlcnkiLCJjZWxseGdlbmUtOTEzNTI0OTQ2MjI2LXVzLWVhc3QtMSIsImNlbGx4Z2VuZS1jZW5zdXMtcHVibGljLXVzLXdlc3QtMiIsImRhdGEtZHJvcC1vZmYtYnVja2V0IiwiZXhhbXBsZS1waGFybWEtZGF0YSIsImZsLTE1OC1yYXciLCJmbC0xNTktcmF3IiwiZmwtMTYwLXJhdyIsImZsLWRhdGEtY29tbW9ucyIsImdhbnltZWRlLXNhbmRib3gtYnVja2V0IiwiZ2RjLWNjbGUtMi1vcGVuIiwibmYtY29yZS1nYWxsZXJ5Iiwib21pY3MtcXVpbHQtb21pY3NxdWlsdGNrYWlucHV0ODUwNzg3NzE3MTk3dXNlYXN0MTMtNThlcGpseXQ1bWNwIiwib21pY3MtcXVpbHQtb21pY3NxdWlsdGNrYW91dHB1dDg1MDc4NzcxNzE5N3VzZWFzdDEtZ3B1eDJqdGp1Y204IiwicG1jLW9hLW9wZW5kYXRhIiwicXVpbHQtYmFrZSIsInF1aWx0LWJlbmNobGluZyIsInF1aWx0LWNjbGUtcGlwZWxpbmUtcnVucyIsInF1aWx0LWNybyIsInF1aWx0LWRlbW9zIiwicXVpbHQtZXhhbXBsZS1idWNrZXQiLCJxdWlsdC1vcGVuLWNjbGUtdmlyZ2luaWEiLCJxdWlsdC1zYWxlcy1yYXciLCJxdWlsdC1zYWxlcy1zdGFnaW5nIiwicXVpbHQtc2FuZGJveC1idWNrZXQiLCJxdWlsdC16cy1zYW5kYm94Iiwic2FsZXMtcHJvZC1jYW5hcnlidWNrZXRhbGxvd2VkLWVpaG8zbnM5d2hjbSIsInNhbGVzLXByb2QtY2FuYXJ5YnVja2V0cmVzdHJpY3RlZC1kZWt3YnZ0eWE0NWYiLCJzYWxlcy1wcm9kLXN0YXR1c3JlcG9ydHNidWNrZXQtdGZienVtNzBkZnU3Iiwic3JhLXB1Yi1ydW4tb2RwIiwidWRwLXNwZWMiLCJ6cy1kaXNjb3Zlcnktb21pY3MiXX0.v7LqlkxMSRk97kqWQ7qs6Ul9rpYm2nLj1w_jFyIQXY4
```
(~2367 bytes)

### Evidence from Network Logs

User's network log showed:
```
"authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6Ijg3OTVmMGNjLThkZWItNDBkZC05MTMyLTEzMzU3Yzk4Mzk4NCIsInV1aWQiOiI3MTI5OGJkZS0xZDI1LTRlNTItYmYxNi1hMzdiOGNmNjI4NGMiLCJleHAiOjE3NjcwNjQ2NTB9.cK_8y0HM2dJLVauvDZEAO1_hc2f6fcKRB76NDnQyRk4"
```

Decoded payload:
```json
{
  "id": "8795f0cc-8deb-40dd-9132-13357c983984",
  "uuid": "71298bde-1d25-4e52-bf16-a37b8cf6284c",
  "exp": 1767064650
}
```

This token is **NOT signed with the enhanced secret** - it's the basic OAuth token from Quilt's auth system! That's why the backend reported "wrong signing secret" - it was comparing apples to oranges.

## Code Changes

### Before (Lines 215-236):
```typescript
const enhancedToken = await authManager.getCurrentToken()
if (enhancedToken) {
  return enhancedToken
}

// Fallback: get original token directly from Redux
const reduxState = store.getState() as any
const { token, source } = findTokenInState(reduxState)
if (token) {
  console.log(`‚úÖ Original token found in Redux state (${source})`)
  return token  // ‚ùå WRONG! This is the basic OAuth token
}

return null
```

### After (Fixed):
```typescript
const enhancedToken = await authManager.getCurrentToken()
if (enhancedToken) {
  console.log('‚úÖ Enhanced token generated', {
    tokenLength: enhancedToken.length,
    tokenPreview: enhancedToken.substring(0, 50) + '...',
  })
  return enhancedToken
}

// CRITICAL: Do NOT fall back to basic OAuth token!
console.error('‚ùå DynamicAuthManager failed to generate enhanced token')
console.error('   Returning null to prevent wrong token type')
return null  // Forces retry logic instead of using wrong token
```

## Why This Matters

The backend requires:
- ‚úÖ Enhanced JWT signed with `7nzzo8vskFWWUrFT2gWq9FhYJmJexXnETFvrzYOtihYXWHW5Ns2VgI6N8lYDxpk0`
- ‚úÖ Roles claim: `["ReadWriteQuiltV2-sales-prod"]`
- ‚úÖ Permissions claim: `[24 AWS permissions]`
- ‚úÖ Buckets claim: `[32 bucket names]`

The basic OAuth token has **none of these** and is signed with a different secret, so backend signature verification fails every time.

## Timeline of Fixes

1. **SSM Newline Fix** - Removed `\n` from backend secret ‚úÖ
2. **Backend Restart** - MCP server reloaded correct secret ‚úÖ
3. **Session Auth Retry** - Added retry logic for token acquisition ‚úÖ
4. **This Fix** - Prevent OAuth token fallback ‚úÖ

## Expected Behavior After Fix

**Browser Console (after opening Qurator):**
```
üîç MCP Client: Redux token getter called...
‚úÖ MCP Client: Enhanced token generated by DynamicAuthManager
  {tokenLength: 2367, tokenPreview: "eyJhbGciOiJIUzI1NiIs..."}
‚úÖ Sending notifications/initialized with Authorization header
  {tokenLength: 2367, hasAuthHeader: true}
‚úÖ notifications/initialized sent successfully
```

**Backend Logs (CloudWatch):**
```
[INFO] JWT authentication succeeded for sub=8795f0cc-8deb-40dd-9132-13357c983984 (permissions=24, buckets=32, roles=1)
```

**Network Tab:**
- Authorization header length: ~2400+ characters
- Token payload includes: roles, permissions, buckets, scope, level

## Success Criteria

- ‚úÖ Version shows 1.64.1a12
- ‚úÖ Token length is ~2367 bytes (not ~200)
- ‚úÖ Token includes roles, permissions, buckets
- ‚úÖ Backend logs "JWT authentication succeeded"
- ‚úÖ MCP tools execute with correct permissions
- ‚úÖ No "wrong signing secret" errors

---

**Status:** ‚úÖ Deployed and Ready for Testing  
**Critical:** This was the root cause of all "wrong signing secret" errors!




